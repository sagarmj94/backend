const { Server } = require("socket.io");
const cookie = require("cookie");
const jwt = require("jsonwebtoken");
const userModel = require("../models/user.model");
const { generateResponse, generateVector } = require("../services/ai.service");

const messageModel = require("../models/message.model");
const { createMemory, queryMemory } = require("../services/vector.service");

function initSocketServer(httpServer) {
    const io = new Server(httpServer, {});

    //middleware for authentication
    io.use(async (socket, next) => {

        const cookiesData = cookie.parse(socket.handshake.headers?.cookie || "");
        if (!cookiesData.token) {
            return next(new Error("Authentication error"));
        }

        // verify token
        try {
            const decoded = jwt.verify(cookiesData.token, process.env.JWT_SECRET);
            const user = await userModel.findById(decoded.id)
            socket.user = user;
            next();
        } catch (err) {
            return next(new Error("Authentication error"));
        }
    });

    // what is this doing?
    // This code sets up a WebSocket server using Socket.IO that listens for incoming connections. It authenticates users based on a JWT token stored in cookies, allowing only authenticated users to connect. Once connected, it listens for "ai-message" events, processes the messages by saving them to a database, generating AI responses using the Google GenAI API, and then sending the responses back to the client. The server also retrieves chat history to provide context for the AI responses.

    io.on("connection", (socket) => {
        socket.on("ai-message", async (messagePayload) => {

            // save user message to db

            //what is this doing?
            // This code saves the user's message to the database as a new message document. It associates the message with the user who is connected via the WebSocket (socket.user._id) and the chat session (messagePayload.chat). The content of the message is taken from the messagePayload, and the role is set to "user" to indicate that this message was sent by a human user rather than an AI model.
            await messageModel.create({
                chat: messagePayload.chat,
                user: socket.user._id,
                content: messagePayload.content,
                role: "user",
            });


            // generate vector embeddings for user message
            // what is this line doing?
            // This line generates vector embeddings for the content of the user's message using the generateVector function from the ai.service module. Vector embeddings are numerical representations of text that capture semantic meaning, allowing for tasks such as similarity search and clustering. These embeddings will be used later to store the message in a vector database (Pinecone) for efficient retrieval and analysis.
            const vectors = await generateVector(messagePayload.content);

            // console.log("messagePayload", messagePayload, socket.user._id, messagePayload.content);
            // what is these lines doing?
            // This code saves the generated vector embeddings of the user's message to a Pinecone vector database. It uses the createMemory function to upsert (insert or update) the vector data, associating it with the user's ID and additional metadata such as the chat ID and the original text content. This allows for efficient retrieval and similarity searches of past messages based on their vector representations.


            // get last 20 messages from db
            const chatHistory = (await messageModel.find({
                chat: messagePayload.chat
            }).sort({
                createdAt: -1
            }).limit(20).lean()).reverse()

            // get ai response
            const response = await generateResponse(chatHistory.map(item => {
                return { role: item.role, parts: [{ text: item.content }] }
            }));

            // save ai response to db
            //what is this doing?
            // This code saves the AI-generated response to the database as a new message document. It associates the message with the user who is connected via the WebSocket (socket.user._id) and the chat session (messagePayload.chat). The content of the message is the AI's response, and the role is set to "model" to indicate that this message was generated by the AI model rather than a human user.
            await messageModel.create({
                user: socket.user._id,
                chat: messagePayload.chat,
                content: response,
                role: "model",
            });


            // what is this doing?
            // This code emits an "ai-response" event back to the connected client via the WebSocket. The event contains the AI-generated response, the chat ID, and the chat history. This allows the client to receive and display the AI's response in real-time as part of the ongoing chat session.
            socket.emit("ai-response", {
                content: response,
                chat: messagePayload.chat,
                history: chatHistory
            });

        });
    });
    return io;
}

module.exports = { initSocketServer };